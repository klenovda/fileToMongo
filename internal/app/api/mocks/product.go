package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i fileToMongo/internal/app/api.Product -o ./mocks/product.go

import (
	"context"
	"fileToMongo/internal/database"
	"fileToMongo/pkg/apipb"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ProductMock implements api.Product
type ProductMock struct {
	t minimock.Tester

	funcFetchCSV          func(ctx context.Context, u string) (err error)
	inspectFuncFetchCSV   func(ctx context.Context, u string)
	afterFetchCSVCounter  uint64
	beforeFetchCSVCounter uint64
	FetchCSVMock          mProductMockFetchCSV

	funcList          func(ctx context.Context, page *apipb.ListRequest_PagingParams, sort *apipb.ListRequest_SortingParams) (ppa1 []*database.Product, err error)
	inspectFuncList   func(ctx context.Context, page *apipb.ListRequest_PagingParams, sort *apipb.ListRequest_SortingParams)
	afterListCounter  uint64
	beforeListCounter uint64
	ListMock          mProductMockList
}

// NewProductMock returns a mock for api.Product
func NewProductMock(t minimock.Tester) *ProductMock {
	m := &ProductMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.FetchCSVMock = mProductMockFetchCSV{mock: m}
	m.FetchCSVMock.callArgs = []*ProductMockFetchCSVParams{}

	m.ListMock = mProductMockList{mock: m}
	m.ListMock.callArgs = []*ProductMockListParams{}

	return m
}

type mProductMockFetchCSV struct {
	mock               *ProductMock
	defaultExpectation *ProductMockFetchCSVExpectation
	expectations       []*ProductMockFetchCSVExpectation

	callArgs []*ProductMockFetchCSVParams
	mutex    sync.RWMutex
}

// ProductMockFetchCSVExpectation specifies expectation struct of the Product.FetchCSV
type ProductMockFetchCSVExpectation struct {
	mock    *ProductMock
	params  *ProductMockFetchCSVParams
	results *ProductMockFetchCSVResults
	Counter uint64
}

// ProductMockFetchCSVParams contains parameters of the Product.FetchCSV
type ProductMockFetchCSVParams struct {
	ctx context.Context
	u   string
}

// ProductMockFetchCSVResults contains results of the Product.FetchCSV
type ProductMockFetchCSVResults struct {
	err error
}

// Expect sets up expected params for Product.FetchCSV
func (mmFetchCSV *mProductMockFetchCSV) Expect(ctx context.Context, u string) *mProductMockFetchCSV {
	if mmFetchCSV.mock.funcFetchCSV != nil {
		mmFetchCSV.mock.t.Fatalf("ProductMock.FetchCSV mock is already set by Set")
	}

	if mmFetchCSV.defaultExpectation == nil {
		mmFetchCSV.defaultExpectation = &ProductMockFetchCSVExpectation{}
	}

	mmFetchCSV.defaultExpectation.params = &ProductMockFetchCSVParams{ctx, u}
	for _, e := range mmFetchCSV.expectations {
		if minimock.Equal(e.params, mmFetchCSV.defaultExpectation.params) {
			mmFetchCSV.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetchCSV.defaultExpectation.params)
		}
	}

	return mmFetchCSV
}

// Inspect accepts an inspector function that has same arguments as the Product.FetchCSV
func (mmFetchCSV *mProductMockFetchCSV) Inspect(f func(ctx context.Context, u string)) *mProductMockFetchCSV {
	if mmFetchCSV.mock.inspectFuncFetchCSV != nil {
		mmFetchCSV.mock.t.Fatalf("Inspect function is already set for ProductMock.FetchCSV")
	}

	mmFetchCSV.mock.inspectFuncFetchCSV = f

	return mmFetchCSV
}

// Return sets up results that will be returned by Product.FetchCSV
func (mmFetchCSV *mProductMockFetchCSV) Return(err error) *ProductMock {
	if mmFetchCSV.mock.funcFetchCSV != nil {
		mmFetchCSV.mock.t.Fatalf("ProductMock.FetchCSV mock is already set by Set")
	}

	if mmFetchCSV.defaultExpectation == nil {
		mmFetchCSV.defaultExpectation = &ProductMockFetchCSVExpectation{mock: mmFetchCSV.mock}
	}
	mmFetchCSV.defaultExpectation.results = &ProductMockFetchCSVResults{err}
	return mmFetchCSV.mock
}

//Set uses given function f to mock the Product.FetchCSV method
func (mmFetchCSV *mProductMockFetchCSV) Set(f func(ctx context.Context, u string) (err error)) *ProductMock {
	if mmFetchCSV.defaultExpectation != nil {
		mmFetchCSV.mock.t.Fatalf("Default expectation is already set for the Product.FetchCSV method")
	}

	if len(mmFetchCSV.expectations) > 0 {
		mmFetchCSV.mock.t.Fatalf("Some expectations are already set for the Product.FetchCSV method")
	}

	mmFetchCSV.mock.funcFetchCSV = f
	return mmFetchCSV.mock
}

// When sets expectation for the Product.FetchCSV which will trigger the result defined by the following
// Then helper
func (mmFetchCSV *mProductMockFetchCSV) When(ctx context.Context, u string) *ProductMockFetchCSVExpectation {
	if mmFetchCSV.mock.funcFetchCSV != nil {
		mmFetchCSV.mock.t.Fatalf("ProductMock.FetchCSV mock is already set by Set")
	}

	expectation := &ProductMockFetchCSVExpectation{
		mock:   mmFetchCSV.mock,
		params: &ProductMockFetchCSVParams{ctx, u},
	}
	mmFetchCSV.expectations = append(mmFetchCSV.expectations, expectation)
	return expectation
}

// Then sets up Product.FetchCSV return parameters for the expectation previously defined by the When method
func (e *ProductMockFetchCSVExpectation) Then(err error) *ProductMock {
	e.results = &ProductMockFetchCSVResults{err}
	return e.mock
}

// FetchCSV implements api.Product
func (mmFetchCSV *ProductMock) FetchCSV(ctx context.Context, u string) (err error) {
	mm_atomic.AddUint64(&mmFetchCSV.beforeFetchCSVCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchCSV.afterFetchCSVCounter, 1)

	if mmFetchCSV.inspectFuncFetchCSV != nil {
		mmFetchCSV.inspectFuncFetchCSV(ctx, u)
	}

	mm_params := &ProductMockFetchCSVParams{ctx, u}

	// Record call args
	mmFetchCSV.FetchCSVMock.mutex.Lock()
	mmFetchCSV.FetchCSVMock.callArgs = append(mmFetchCSV.FetchCSVMock.callArgs, mm_params)
	mmFetchCSV.FetchCSVMock.mutex.Unlock()

	for _, e := range mmFetchCSV.FetchCSVMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmFetchCSV.FetchCSVMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchCSV.FetchCSVMock.defaultExpectation.Counter, 1)
		mm_want := mmFetchCSV.FetchCSVMock.defaultExpectation.params
		mm_got := ProductMockFetchCSVParams{ctx, u}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFetchCSV.t.Errorf("ProductMock.FetchCSV got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFetchCSV.FetchCSVMock.defaultExpectation.results
		if mm_results == nil {
			mmFetchCSV.t.Fatal("No results are set for the ProductMock.FetchCSV")
		}
		return (*mm_results).err
	}
	if mmFetchCSV.funcFetchCSV != nil {
		return mmFetchCSV.funcFetchCSV(ctx, u)
	}
	mmFetchCSV.t.Fatalf("Unexpected call to ProductMock.FetchCSV. %v %v", ctx, u)
	return
}

// FetchCSVAfterCounter returns a count of finished ProductMock.FetchCSV invocations
func (mmFetchCSV *ProductMock) FetchCSVAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchCSV.afterFetchCSVCounter)
}

// FetchCSVBeforeCounter returns a count of ProductMock.FetchCSV invocations
func (mmFetchCSV *ProductMock) FetchCSVBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchCSV.beforeFetchCSVCounter)
}

// Calls returns a list of arguments used in each call to ProductMock.FetchCSV.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetchCSV *mProductMockFetchCSV) Calls() []*ProductMockFetchCSVParams {
	mmFetchCSV.mutex.RLock()

	argCopy := make([]*ProductMockFetchCSVParams, len(mmFetchCSV.callArgs))
	copy(argCopy, mmFetchCSV.callArgs)

	mmFetchCSV.mutex.RUnlock()

	return argCopy
}

// MinimockFetchCSVDone returns true if the count of the FetchCSV invocations corresponds
// the number of defined expectations
func (m *ProductMock) MinimockFetchCSVDone() bool {
	for _, e := range m.FetchCSVMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchCSVMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchCSVCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchCSV != nil && mm_atomic.LoadUint64(&m.afterFetchCSVCounter) < 1 {
		return false
	}
	return true
}

// MinimockFetchCSVInspect logs each unmet expectation
func (m *ProductMock) MinimockFetchCSVInspect() {
	for _, e := range m.FetchCSVMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProductMock.FetchCSV with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchCSVMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchCSVCounter) < 1 {
		if m.FetchCSVMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ProductMock.FetchCSV")
		} else {
			m.t.Errorf("Expected call to ProductMock.FetchCSV with params: %#v", *m.FetchCSVMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchCSV != nil && mm_atomic.LoadUint64(&m.afterFetchCSVCounter) < 1 {
		m.t.Error("Expected call to ProductMock.FetchCSV")
	}
}

type mProductMockList struct {
	mock               *ProductMock
	defaultExpectation *ProductMockListExpectation
	expectations       []*ProductMockListExpectation

	callArgs []*ProductMockListParams
	mutex    sync.RWMutex
}

// ProductMockListExpectation specifies expectation struct of the Product.List
type ProductMockListExpectation struct {
	mock    *ProductMock
	params  *ProductMockListParams
	results *ProductMockListResults
	Counter uint64
}

// ProductMockListParams contains parameters of the Product.List
type ProductMockListParams struct {
	ctx  context.Context
	page *apipb.ListRequest_PagingParams
	sort *apipb.ListRequest_SortingParams
}

// ProductMockListResults contains results of the Product.List
type ProductMockListResults struct {
	ppa1 []*database.Product
	err  error
}

// Expect sets up expected params for Product.List
func (mmList *mProductMockList) Expect(ctx context.Context, page *apipb.ListRequest_PagingParams, sort *apipb.ListRequest_SortingParams) *mProductMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("ProductMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &ProductMockListExpectation{}
	}

	mmList.defaultExpectation.params = &ProductMockListParams{ctx, page, sort}
	for _, e := range mmList.expectations {
		if minimock.Equal(e.params, mmList.defaultExpectation.params) {
			mmList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmList.defaultExpectation.params)
		}
	}

	return mmList
}

// Inspect accepts an inspector function that has same arguments as the Product.List
func (mmList *mProductMockList) Inspect(f func(ctx context.Context, page *apipb.ListRequest_PagingParams, sort *apipb.ListRequest_SortingParams)) *mProductMockList {
	if mmList.mock.inspectFuncList != nil {
		mmList.mock.t.Fatalf("Inspect function is already set for ProductMock.List")
	}

	mmList.mock.inspectFuncList = f

	return mmList
}

// Return sets up results that will be returned by Product.List
func (mmList *mProductMockList) Return(ppa1 []*database.Product, err error) *ProductMock {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("ProductMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &ProductMockListExpectation{mock: mmList.mock}
	}
	mmList.defaultExpectation.results = &ProductMockListResults{ppa1, err}
	return mmList.mock
}

//Set uses given function f to mock the Product.List method
func (mmList *mProductMockList) Set(f func(ctx context.Context, page *apipb.ListRequest_PagingParams, sort *apipb.ListRequest_SortingParams) (ppa1 []*database.Product, err error)) *ProductMock {
	if mmList.defaultExpectation != nil {
		mmList.mock.t.Fatalf("Default expectation is already set for the Product.List method")
	}

	if len(mmList.expectations) > 0 {
		mmList.mock.t.Fatalf("Some expectations are already set for the Product.List method")
	}

	mmList.mock.funcList = f
	return mmList.mock
}

// When sets expectation for the Product.List which will trigger the result defined by the following
// Then helper
func (mmList *mProductMockList) When(ctx context.Context, page *apipb.ListRequest_PagingParams, sort *apipb.ListRequest_SortingParams) *ProductMockListExpectation {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("ProductMock.List mock is already set by Set")
	}

	expectation := &ProductMockListExpectation{
		mock:   mmList.mock,
		params: &ProductMockListParams{ctx, page, sort},
	}
	mmList.expectations = append(mmList.expectations, expectation)
	return expectation
}

// Then sets up Product.List return parameters for the expectation previously defined by the When method
func (e *ProductMockListExpectation) Then(ppa1 []*database.Product, err error) *ProductMock {
	e.results = &ProductMockListResults{ppa1, err}
	return e.mock
}

// List implements api.Product
func (mmList *ProductMock) List(ctx context.Context, page *apipb.ListRequest_PagingParams, sort *apipb.ListRequest_SortingParams) (ppa1 []*database.Product, err error) {
	mm_atomic.AddUint64(&mmList.beforeListCounter, 1)
	defer mm_atomic.AddUint64(&mmList.afterListCounter, 1)

	if mmList.inspectFuncList != nil {
		mmList.inspectFuncList(ctx, page, sort)
	}

	mm_params := &ProductMockListParams{ctx, page, sort}

	// Record call args
	mmList.ListMock.mutex.Lock()
	mmList.ListMock.callArgs = append(mmList.ListMock.callArgs, mm_params)
	mmList.ListMock.mutex.Unlock()

	for _, e := range mmList.ListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmList.ListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmList.ListMock.defaultExpectation.Counter, 1)
		mm_want := mmList.ListMock.defaultExpectation.params
		mm_got := ProductMockListParams{ctx, page, sort}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmList.t.Errorf("ProductMock.List got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmList.ListMock.defaultExpectation.results
		if mm_results == nil {
			mmList.t.Fatal("No results are set for the ProductMock.List")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmList.funcList != nil {
		return mmList.funcList(ctx, page, sort)
	}
	mmList.t.Fatalf("Unexpected call to ProductMock.List. %v %v %v", ctx, page, sort)
	return
}

// ListAfterCounter returns a count of finished ProductMock.List invocations
func (mmList *ProductMock) ListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.afterListCounter)
}

// ListBeforeCounter returns a count of ProductMock.List invocations
func (mmList *ProductMock) ListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.beforeListCounter)
}

// Calls returns a list of arguments used in each call to ProductMock.List.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmList *mProductMockList) Calls() []*ProductMockListParams {
	mmList.mutex.RLock()

	argCopy := make([]*ProductMockListParams, len(mmList.callArgs))
	copy(argCopy, mmList.callArgs)

	mmList.mutex.RUnlock()

	return argCopy
}

// MinimockListDone returns true if the count of the List invocations corresponds
// the number of defined expectations
func (m *ProductMock) MinimockListDone() bool {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		return false
	}
	return true
}

// MinimockListInspect logs each unmet expectation
func (m *ProductMock) MinimockListInspect() {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProductMock.List with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		if m.ListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ProductMock.List")
		} else {
			m.t.Errorf("Expected call to ProductMock.List with params: %#v", *m.ListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		m.t.Error("Expected call to ProductMock.List")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ProductMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockFetchCSVInspect()

		m.MinimockListInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ProductMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ProductMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockFetchCSVDone() &&
		m.MinimockListDone()
}
